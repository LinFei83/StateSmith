// Autogenerated with StateSmith 0.17.5+14a731834f095c7ca52667d376f7f294522cc31e.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "electromagnet.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
#include "electromagnet_state_machine.h"


// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(electromagnet* sm, electromagnet_StateId desired_state);

static void ROOT_enter(electromagnet* sm);

static void ADC_CALIBRATION_enter(electromagnet* sm);

static void ADC_CALIBRATION_exit(electromagnet* sm);

static void ADC_CALIBRATION_adc_calibration_complete(electromagnet* sm);

static void ADC_CALIBRATION_calibration_failed(electromagnet* sm);

static void ADC_CALIBRATION_do(electromagnet* sm);

static void SYSTEM_ERROR_enter(electromagnet* sm);

static void SYSTEM_ERROR_exit(electromagnet* sm);

static void SYSTEM_INITIALIZATION_enter(electromagnet* sm);

static void SYSTEM_INITIALIZATION_exit(electromagnet* sm);

static void SYSTEM_INITIALIZATION_do(electromagnet* sm);

static void SYSTEM_RUN_enter(electromagnet* sm);

static void SYSTEM_RUN_exit(electromagnet* sm);

static void SYSTEM_RUN_control_anomaly(electromagnet* sm);

static void SYSTEM_RUN_do(electromagnet* sm);

static void SYSTEM_RUN_stop_the_request(electromagnet* sm);

static void ELECTRICITY_CONTROL_MODE_enter(electromagnet* sm);

static void ELECTRICITY_CONTROL_MODE_exit(electromagnet* sm);

static void ELECTRICITY_CONTROL_MODE_get_on_standby(electromagnet* sm);

static void CHANGE_OF_OBJECTIVE_enter(electromagnet* sm);

static void CHANGE_OF_OBJECTIVE_exit(electromagnet* sm);

static void CHANGE_OF_OBJECTIVE_do(electromagnet* sm);

static void ELECTRICITY_CONTROL_enter(electromagnet* sm);

static void ELECTRICITY_CONTROL_exit(electromagnet* sm);

static void ELECTRICITY_CONTROL_do(electromagnet* sm);

static void ELECTRICITY_CONTROL_needed_referral(electromagnet* sm);

static void ELECTRICITY_CONTROL_target_current_change(electromagnet* sm);

static void INITIALIZATION_OF_PID_enter(electromagnet* sm);

static void INITIALIZATION_OF_PID_exit(electromagnet* sm);

static void INITIALIZATION_OF_PID_do(electromagnet* sm);

static void PARAMETER_ADJUSTMENTS_enter(electromagnet* sm);

static void PARAMETER_ADJUSTMENTS_exit(electromagnet* sm);

static void PARAMETER_ADJUSTMENTS_do(electromagnet* sm);

static void STANDBY_enter(electromagnet* sm);

static void STANDBY_exit(electromagnet* sm);

static void STANDBY_power_control(electromagnet* sm);

static void SYSTEM_STOP_enter(electromagnet* sm);

static void SYSTEM_STOP_exit(electromagnet* sm);

static void SYSTEM_STOP_do(electromagnet* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void electromagnet_ctor(electromagnet* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void electromagnet_start(electromagnet* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(System_Initialization)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `System_Initialization`.
            SYSTEM_INITIALIZATION_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void electromagnet_dispatch_event(electromagnet* sm, electromagnet_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: electromagnet
        case electromagnet_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Adc_Calibration
        case electromagnet_StateId_ADC_CALIBRATION:
            switch (event_id)
            {
                case electromagnet_EventId_DO: ADC_CALIBRATION_do(sm); break;
                case electromagnet_EventId_ADC_CALIBRATION_COMPLETE: ADC_CALIBRATION_adc_calibration_complete(sm); break;
                case electromagnet_EventId_CALIBRATION_FAILED: ADC_CALIBRATION_calibration_failed(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: System_Error
        case electromagnet_StateId_SYSTEM_ERROR:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: System_Initialization
        case electromagnet_StateId_SYSTEM_INITIALIZATION:
            switch (event_id)
            {
                case electromagnet_EventId_DO: SYSTEM_INITIALIZATION_do(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: System_Run
        case electromagnet_StateId_SYSTEM_RUN:
            switch (event_id)
            {
                case electromagnet_EventId_DO: SYSTEM_RUN_do(sm); break;
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break;
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Electricity_Control_Mode
        case electromagnet_StateId_ELECTRICITY_CONTROL_MODE:
            switch (event_id)
            {
                case electromagnet_EventId_GET_ON_STANDBY: ELECTRICITY_CONTROL_MODE_get_on_standby(sm); break;
                case electromagnet_EventId_DO: SYSTEM_RUN_do(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Change_Of_Objective
        case electromagnet_StateId_CHANGE_OF_OBJECTIVE:
            switch (event_id)
            {
                case electromagnet_EventId_DO: CHANGE_OF_OBJECTIVE_do(sm); break;
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_GET_ON_STANDBY: ELECTRICITY_CONTROL_MODE_get_on_standby(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Electricity_Control
        case electromagnet_StateId_ELECTRICITY_CONTROL:
            switch (event_id)
            {
                case electromagnet_EventId_DO: ELECTRICITY_CONTROL_do(sm); break;
                case electromagnet_EventId_NEEDED_REFERRAL: ELECTRICITY_CONTROL_needed_referral(sm); break;
                case electromagnet_EventId_TARGET_CURRENT_CHANGE: ELECTRICITY_CONTROL_target_current_change(sm); break;
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_GET_ON_STANDBY: ELECTRICITY_CONTROL_MODE_get_on_standby(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Initialization_Of_Pid
        case electromagnet_StateId_INITIALIZATION_OF_PID:
            switch (event_id)
            {
                case electromagnet_EventId_DO: INITIALIZATION_OF_PID_do(sm); break;
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_GET_ON_STANDBY: ELECTRICITY_CONTROL_MODE_get_on_standby(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Parameter_Adjustments
        case electromagnet_StateId_PARAMETER_ADJUSTMENTS:
            switch (event_id)
            {
                case electromagnet_EventId_DO: PARAMETER_ADJUSTMENTS_do(sm); break;
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_GET_ON_STANDBY: ELECTRICITY_CONTROL_MODE_get_on_standby(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Standby
        case electromagnet_StateId_STANDBY:
            switch (event_id)
            {
                case electromagnet_EventId_POWER_CONTROL: STANDBY_power_control(sm); break;
                case electromagnet_EventId_DO: SYSTEM_RUN_do(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_CONTROL_ANOMALY: SYSTEM_RUN_control_anomaly(sm); break; // First ancestor handler for this event
                case electromagnet_EventId_STOP_THE_REQUEST: SYSTEM_RUN_stop_the_request(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: System_Stop
        case electromagnet_StateId_SYSTEM_STOP:
            switch (event_id)
            {
                case electromagnet_EventId_DO: SYSTEM_STOP_do(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(electromagnet* sm, electromagnet_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case electromagnet_StateId_ADC_CALIBRATION: ADC_CALIBRATION_exit(sm); break;
            
            case electromagnet_StateId_SYSTEM_ERROR: SYSTEM_ERROR_exit(sm); break;
            
            case electromagnet_StateId_SYSTEM_INITIALIZATION: SYSTEM_INITIALIZATION_exit(sm); break;
            
            case electromagnet_StateId_SYSTEM_RUN: SYSTEM_RUN_exit(sm); break;
            
            case electromagnet_StateId_ELECTRICITY_CONTROL_MODE: ELECTRICITY_CONTROL_MODE_exit(sm); break;
            
            case electromagnet_StateId_CHANGE_OF_OBJECTIVE: CHANGE_OF_OBJECTIVE_exit(sm); break;
            
            case electromagnet_StateId_ELECTRICITY_CONTROL: ELECTRICITY_CONTROL_exit(sm); break;
            
            case electromagnet_StateId_INITIALIZATION_OF_PID: INITIALIZATION_OF_PID_exit(sm); break;
            
            case electromagnet_StateId_PARAMETER_ADJUSTMENTS: PARAMETER_ADJUSTMENTS_exit(sm); break;
            
            case electromagnet_StateId_STANDBY: STANDBY_exit(sm); break;
            
            case electromagnet_StateId_SYSTEM_STOP: SYSTEM_STOP_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ADC_CALIBRATION
////////////////////////////////////////////////////////////////////////////////

static void ADC_CALIBRATION_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ADC_CALIBRATION;
    
    // Adc_Calibration behavior
    // uml: enter / { adc_calibration_enter(); }
    {
        // Step 1: execute action `adc_calibration_enter();`
        adc_calibration_enter();
    } // end of behavior for Adc_Calibration
}

static void ADC_CALIBRATION_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ROOT;
}

static void ADC_CALIBRATION_adc_calibration_complete(electromagnet* sm)
{
    // Adc_Calibration behavior
    // uml: adc_calibration_complete TransitionTo(System_Run)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ADC_CALIBRATION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `System_Run`.
        SYSTEM_RUN_enter(sm);
        
        // System_Run.<InitialState> behavior
        // uml: TransitionTo(Standby)
        {
            // Step 1: Exit states until we reach `System_Run` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Standby`.
            STANDBY_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for System_Run.<InitialState>
    } // end of behavior for Adc_Calibration
    
    // No ancestor handles this event.
}

static void ADC_CALIBRATION_calibration_failed(electromagnet* sm)
{
    // Adc_Calibration behavior
    // uml: calibration_failed TransitionTo(System_Error)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ADC_CALIBRATION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `System_Error`.
        SYSTEM_ERROR_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Adc_Calibration
    
    // No ancestor handles this event.
}

static void ADC_CALIBRATION_do(electromagnet* sm)
{
    // Adc_Calibration behavior
    // uml: do / { adc_calibration_do(); }
    {
        // Step 1: execute action `adc_calibration_do();`
        adc_calibration_do();
    } // end of behavior for Adc_Calibration
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SYSTEM_ERROR
////////////////////////////////////////////////////////////////////////////////

static void SYSTEM_ERROR_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_SYSTEM_ERROR;
    
    // System_Error behavior
    // uml: enter / { system_error_enter(); }
    {
        // Step 1: execute action `system_error_enter();`
        system_error_enter();
    } // end of behavior for System_Error
}

static void SYSTEM_ERROR_exit(electromagnet* sm)
{
    // System_Error behavior
    // uml: exit / { system_error_exit(); }
    {
        // Step 1: execute action `system_error_exit();`
        system_error_exit();
    } // end of behavior for System_Error
    
    sm->state_id = electromagnet_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SYSTEM_INITIALIZATION
////////////////////////////////////////////////////////////////////////////////

static void SYSTEM_INITIALIZATION_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_SYSTEM_INITIALIZATION;
    
    // System_Initialization behavior
    // uml: enter / { system_init_enter(); }
    {
        // Step 1: execute action `system_init_enter();`
        system_init_enter();
    } // end of behavior for System_Initialization
}

static void SYSTEM_INITIALIZATION_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ROOT;
}

static void SYSTEM_INITIALIZATION_do(electromagnet* sm)
{
    // System_Initialization behavior
    // uml: do TransitionTo(Adc_Calibration)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SYSTEM_INITIALIZATION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Adc_Calibration`.
        ADC_CALIBRATION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for System_Initialization
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SYSTEM_RUN
////////////////////////////////////////////////////////////////////////////////

static void SYSTEM_RUN_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_SYSTEM_RUN;
}

static void SYSTEM_RUN_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ROOT;
}

static void SYSTEM_RUN_control_anomaly(electromagnet* sm)
{
    // System_Run behavior
    // uml: control_anomaly TransitionTo(System_Error)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, electromagnet_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `System_Error`.
        SYSTEM_ERROR_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for System_Run
    
    // No ancestor handles this event.
}

static void SYSTEM_RUN_do(electromagnet* sm)
{
    // System_Run behavior
    // uml: do / { system_running_do(); }
    {
        // Step 1: execute action `system_running_do();`
        system_running_do();
    } // end of behavior for System_Run
    
    // No ancestor handles this event.
}

static void SYSTEM_RUN_stop_the_request(electromagnet* sm)
{
    // System_Run behavior
    // uml: stop_the_request TransitionTo(System_Stop)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, electromagnet_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `System_Stop`.
        SYSTEM_STOP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for System_Run
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ELECTRICITY_CONTROL_MODE
////////////////////////////////////////////////////////////////////////////////

static void ELECTRICITY_CONTROL_MODE_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL_MODE;
}

static void ELECTRICITY_CONTROL_MODE_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_SYSTEM_RUN;
}

static void ELECTRICITY_CONTROL_MODE_get_on_standby(electromagnet* sm)
{
    // Electricity_Control_Mode behavior
    // uml: get_on_standby TransitionTo(Standby)
    {
        // Step 1: Exit states until we reach `System_Run` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, electromagnet_StateId_SYSTEM_RUN);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Standby`.
        STANDBY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Electricity_Control_Mode
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANGE_OF_OBJECTIVE
////////////////////////////////////////////////////////////////////////////////

static void CHANGE_OF_OBJECTIVE_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_CHANGE_OF_OBJECTIVE;
    
    // Change_Of_Objective behavior
    // uml: enter / { target_change_enter(); }
    {
        // Step 1: execute action `target_change_enter();`
        target_change_enter();
    } // end of behavior for Change_Of_Objective
}

static void CHANGE_OF_OBJECTIVE_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL_MODE;
}

static void CHANGE_OF_OBJECTIVE_do(electromagnet* sm)
{
    bool consume_event = false;
    
    // Change_Of_Objective behavior
    // uml: do TransitionTo(Electricity_Control)
    {
        // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition).
        CHANGE_OF_OBJECTIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Electricity_Control`.
        ELECTRICITY_CONTROL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Change_Of_Objective
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        SYSTEM_RUN_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ELECTRICITY_CONTROL
////////////////////////////////////////////////////////////////////////////////

static void ELECTRICITY_CONTROL_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL;
    
    // Electricity_Control behavior
    // uml: enter / { current_control_enter(); }
    {
        // Step 1: execute action `current_control_enter();`
        current_control_enter();
    } // end of behavior for Electricity_Control
}

static void ELECTRICITY_CONTROL_exit(electromagnet* sm)
{
    // Electricity_Control behavior
    // uml: exit / { current_control_exit(); }
    {
        // Step 1: execute action `current_control_exit();`
        current_control_exit();
    } // end of behavior for Electricity_Control
    
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL_MODE;
}

static void ELECTRICITY_CONTROL_do(electromagnet* sm)
{
    bool consume_event = false;
    
    // Electricity_Control behavior
    // uml: do / { current_control_do(); }
    {
        // `do` events are not normally consumed.
        // Step 1: execute action `current_control_do();`
        current_control_do();
    } // end of behavior for Electricity_Control
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        SYSTEM_RUN_do(sm);
    }
}

static void ELECTRICITY_CONTROL_needed_referral(electromagnet* sm)
{
    // Electricity_Control behavior
    // uml: needed_referral TransitionTo(Parameter_Adjustments)
    {
        // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition).
        ELECTRICITY_CONTROL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Parameter_Adjustments`.
        PARAMETER_ADJUSTMENTS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Electricity_Control
    
    // No ancestor handles this event.
}

static void ELECTRICITY_CONTROL_target_current_change(electromagnet* sm)
{
    // Electricity_Control behavior
    // uml: target_current_change TransitionTo(Change_Of_Objective)
    {
        // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition).
        ELECTRICITY_CONTROL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Change_Of_Objective`.
        CHANGE_OF_OBJECTIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Electricity_Control
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state INITIALIZATION_OF_PID
////////////////////////////////////////////////////////////////////////////////

static void INITIALIZATION_OF_PID_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_INITIALIZATION_OF_PID;
    
    // Initialization_Of_Pid behavior
    // uml: enter / { pid_init_enter(); }
    {
        // Step 1: execute action `pid_init_enter();`
        pid_init_enter();
    } // end of behavior for Initialization_Of_Pid
}

static void INITIALIZATION_OF_PID_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL_MODE;
}

static void INITIALIZATION_OF_PID_do(electromagnet* sm)
{
    bool consume_event = false;
    
    // Initialization_Of_Pid behavior
    // uml: do TransitionTo(Electricity_Control)
    {
        // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition).
        INITIALIZATION_OF_PID_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Electricity_Control`.
        ELECTRICITY_CONTROL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Initialization_Of_Pid
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        SYSTEM_RUN_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PARAMETER_ADJUSTMENTS
////////////////////////////////////////////////////////////////////////////////

static void PARAMETER_ADJUSTMENTS_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_PARAMETER_ADJUSTMENTS;
    
    // Parameter_Adjustments behavior
    // uml: enter / { parameter_adjust_enter(); }
    {
        // Step 1: execute action `parameter_adjust_enter();`
        parameter_adjust_enter();
    } // end of behavior for Parameter_Adjustments
}

static void PARAMETER_ADJUSTMENTS_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ELECTRICITY_CONTROL_MODE;
}

static void PARAMETER_ADJUSTMENTS_do(electromagnet* sm)
{
    bool consume_event = false;
    
    // Parameter_Adjustments behavior
    // uml: do TransitionTo(Electricity_Control)
    {
        // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition).
        PARAMETER_ADJUSTMENTS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Electricity_Control`.
        ELECTRICITY_CONTROL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Parameter_Adjustments
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        SYSTEM_RUN_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STANDBY
////////////////////////////////////////////////////////////////////////////////

static void STANDBY_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_STANDBY;
    
    // Standby behavior
    // uml: enter / { system_pause_enter(); }
    {
        // Step 1: execute action `system_pause_enter();`
        system_pause_enter();
    } // end of behavior for Standby
}

static void STANDBY_exit(electromagnet* sm)
{
    // Standby behavior
    // uml: exit / { system_pause_exit(); }
    {
        // Step 1: execute action `system_pause_exit();`
        system_pause_exit();
    } // end of behavior for Standby
    
    sm->state_id = electromagnet_StateId_SYSTEM_RUN;
}

static void STANDBY_power_control(electromagnet* sm)
{
    // Standby behavior
    // uml: power_control TransitionTo(Electricity_Control_Mode)
    {
        // Step 1: Exit states until we reach `System_Run` state (Least Common Ancestor for transition).
        STANDBY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Electricity_Control_Mode`.
        ELECTRICITY_CONTROL_MODE_enter(sm);
        
        // Electricity_Control_Mode.<InitialState> behavior
        // uml: TransitionTo(Initialization_Of_Pid)
        {
            // Step 1: Exit states until we reach `Electricity_Control_Mode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Initialization_Of_Pid`.
            INITIALIZATION_OF_PID_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Electricity_Control_Mode.<InitialState>
    } // end of behavior for Standby
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SYSTEM_STOP
////////////////////////////////////////////////////////////////////////////////

static void SYSTEM_STOP_enter(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_SYSTEM_STOP;
    
    // System_Stop behavior
    // uml: enter / { system_stop_enter(); }
    {
        // Step 1: execute action `system_stop_enter();`
        system_stop_enter();
    } // end of behavior for System_Stop
}

static void SYSTEM_STOP_exit(electromagnet* sm)
{
    sm->state_id = electromagnet_StateId_ROOT;
}

static void SYSTEM_STOP_do(electromagnet* sm)
{
    // System_Stop behavior
    // uml: do / { system_stop_do(); }
    {
        // Step 1: execute action `system_stop_do();`
        system_stop_do();
    } // end of behavior for System_Stop
    
    // No ancestor handles this event.
}

// Thread safe.
char const * electromagnet_state_id_to_string(electromagnet_StateId id)
{
    switch (id)
    {
        case electromagnet_StateId_ROOT: return "ROOT";
        case electromagnet_StateId_ADC_CALIBRATION: return "ADC_CALIBRATION";
        case electromagnet_StateId_SYSTEM_ERROR: return "SYSTEM_ERROR";
        case electromagnet_StateId_SYSTEM_INITIALIZATION: return "SYSTEM_INITIALIZATION";
        case electromagnet_StateId_SYSTEM_RUN: return "SYSTEM_RUN";
        case electromagnet_StateId_ELECTRICITY_CONTROL_MODE: return "ELECTRICITY_CONTROL_MODE";
        case electromagnet_StateId_CHANGE_OF_OBJECTIVE: return "CHANGE_OF_OBJECTIVE";
        case electromagnet_StateId_ELECTRICITY_CONTROL: return "ELECTRICITY_CONTROL";
        case electromagnet_StateId_INITIALIZATION_OF_PID: return "INITIALIZATION_OF_PID";
        case electromagnet_StateId_PARAMETER_ADJUSTMENTS: return "PARAMETER_ADJUSTMENTS";
        case electromagnet_StateId_STANDBY: return "STANDBY";
        case electromagnet_StateId_SYSTEM_STOP: return "SYSTEM_STOP";
        default: return "?";
    }
}

// Thread safe.
char const * electromagnet_event_id_to_string(electromagnet_EventId id)
{
    switch (id)
    {
        case electromagnet_EventId_ADC_CALIBRATION_COMPLETE: return "ADC_CALIBRATION_COMPLETE";
        case electromagnet_EventId_CALIBRATION_FAILED: return "CALIBRATION_FAILED";
        case electromagnet_EventId_CONTROL_ANOMALY: return "CONTROL_ANOMALY";
        case electromagnet_EventId_DO: return "DO";
        case electromagnet_EventId_GET_ON_STANDBY: return "GET_ON_STANDBY";
        case electromagnet_EventId_NEEDED_REFERRAL: return "NEEDED_REFERRAL";
        case electromagnet_EventId_POWER_CONTROL: return "POWER_CONTROL";
        case electromagnet_EventId_STOP_THE_REQUEST: return "STOP_THE_REQUEST";
        case electromagnet_EventId_TARGET_CURRENT_CHANGE: return "TARGET_CURRENT_CHANGE";
        default: return "?";
    }
}
